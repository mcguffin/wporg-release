/*
Builds a github release from current version number
*/

const colors = require('colors');
const wp = require('../wp-header.js');
const fs = require('fs');
const glob = require('glob');
const git = require('simple-git')('.');
const exec = require('child_process');
const https = require('https');
const prompts = require('prompts');
const { doing } = require('../doing.js');
const pack = require('./pack.js');
const keychain = require('../keychain.js');

const setup = async package => {
	if ( package.wporg.git.host !== 'github.com' ) {
		return;
	}
	let current_task;
	console.log( 'Configuring github release process'.white.bold );

	if ( process.platform === 'darwin' ) {
		let token,
			token_label;
		current_task = doing( 'Lookup Github access token in system keychain', 'Found one!', 'Please configure!' );
		try {
			token = exec.execSync( `security find-generic-password -a ${package.wporg.git.user} -s "https://api.github.com" -w`, { encoding: 'utf8' } );
			current_task.ok();
		} catch( err ) {
			current_task.fail();
			console.log('Please create an access token with Scope `repo` enabled on github: <https://github.com/settings/tokens>');

			const token_prompt = await prompts([
				{
					type: 'password',
					name: 'token',
					message: `Access token:`,
					initial: ''
				},
				{
					type: 'text',
					name: 'label',
					message: 'Label in MacOS Keychain:',
					initial: `<${package.wporg.git.user}@api.github.com> wporg-release`
				}
			], { onCancel: process.exit });

			if ( token_prompt.token !== '' ) {
				keychain.add( response.package.wporg.git.user, 'https://api.github.com', token_prompt.token, 'Generated by mcguffin/wporg-release' )
//				exec.execSync( `security add-generic-password -a "${package.wporg.git.user}" -l "${token_prompt.label}" -s "https://api.github.com" -j "Generated by mcguffin/wporg-release" -w "${token_prompt.token}"` );
				console.log('Token added to MacOS Keychain');
				console.log(`Account: ${package.wporg.git.user}`);
				console.log(`Where: https://api.github.com` );
				console.log(`Label: ${package.wporg.git.label}`);
			}
		}
		package.wporg.steps.push( 'github' );
	} else {
		// ...
	}
}

const run = ( dry = false ) => {
	return new Promise( ( resolve, reject ) => {

		let current_task;

		const package = require( process.cwd() + '/package.json' );

		const get_repo_data = () => new Promise( ( resolve_repo, reject_repo ) => {
			current_task = doing('Get git config')
			git
				.listRemote(['--get-url'], (err,res) => {
					if ( err ) {
						current_task.fail();
						reject_repo();
					} else {
						try {
							repo = res.match(/^git@github\.com:(.+)\.git/s)[1];
						} catch (err) {
							repo = res.match(/^git@github\.com:(.+)/s)[1];
						}
					}
				})
				.branch( (err,res) => {
					if ( err ) {
						current_task.fail();
						reject_repo();
					} else {
						branch = res.current;
					}
				})
				.exec( () => {
					token = keychain.get( package.wporg.git.user, 'https://api.github.com' )
					//token = exec.execSync( `security find-generic-password -a ${package.wporg.git.user} -s "https://api.github.com" -w`, { encoding: 'utf8' } ).trim();
					current_task.ok();
					resolve_repo( [ repo, branch, token ] )
				} );

		});
		const send_api_request = ( api_url, req_data, headers = {} ) => new Promise( ( resolve_release, reject_release ) => {
			if ( dry ) {
				console.log(`... api request data:`)
				console.log('url: ' + api_url.replace(/:([a-z0-9]+)@/,'**************'));
				console.log(req_data);
				resolve({});
			} else {
				let resp_data = '';

				const req = https.request( api_url, {
					// host: 'api.github.com',
					// port: 443,
					// path: `repos/${repo}/releases`,
					method: null === req_data ? 'GET' : 'POST',
					headers: {
		//				'Authorization' : 'token ${token}',
						'User-Agent' : 'Nodejs',
						...headers
					}
				}, resp => {
					resp.setEncoding('utf8');
					resp.on('data',data => {
						resp_data += data;
					});
					resp.on('end',() => {
						const resp = JSON.parse( resp_data );
						if ( !! resp.id ) {
							resolve_release( resp );
						} else {
							reject_release( resp );
						}
					});
					resp.on('error',error => {
						reject(error);
					});
				});
				if ( !! req_data && !! req_data.constructor && fs.ReadStream === req_data.constructor ) {
					req_data
						// set "end" to false in the options so .end() isnt called on the request
						.pipe( req, { end: false }) // maybe write directly to the socket here?
						.on( 'end', function() {
							// mark the end of the one and only part
							request.end();
						});
				} else if ( 'object' === typeof req_data ) {
					req.write( JSON.stringify( req_data, null ) );
					req.end();
				} else if ( 'string' === typeof req_data ) {
					req.write( req_data );
					req.end();
				} else if ( req_data.constructor === Buffer ) {
					req.write( req_data.toString('binary') );
				} else {
					req.end();
				}
			}

		} );
/*

# mk zip
zips = [ '%s.zip' % (repo_name), '%s-%s.zip' % ( repo_name, new_version ) ]
zips = [ '%s.zip' % (repo_name) ]
for zip_name in zips:

	# upload zip to tag
	print('Upload ZIP...')
	upload_url = '%s?name=%s' % ( re.sub( r'{\?.*}$', '', api_response['upload_url'] ), zip_name )
	hdl = open('../%s' % ( zip_name ),'rb')

	# post file
	upload_req = urllib.request.Request( upload_url,
		data = hdl.read(),
		headers = {
			'Authorization' : 'token %s' % (access_token),
			'Content-Type' : 'application/zip'
		}
	)
	with urllib.request.urlopen( upload_req ) as f:
		# parse response
		upload_response = json.loads( f.read().decode('utf-8') )

	print('Cleanup...')
	shell('rm ../%s' % zip_name )

*/

		/**
		 *	@return [ send_api_request_url, send_api_request_data ]
		 */
		const get_release_data = () => {

			const data = {
				version:		package.version,
				branch:			branch,
				require_wp:		wp.read_header_tag('readme.txt', 'Requires at least' ),
				max_wp:			wp.read_header_tag('readme.txt', 'Tested up to' ),
				require_php:	wp.read_header_tag('readme.txt', 'Requires PHP' ),
			}

			const req_data = {
				tag_name:			package.version,
				name:				package.version,
				body:				`Release ${data.version} from ${data.branch}

Requires at least: ${data.require_wp}
Tested up to: ${data.max_wp}
Requires PHP: ${data.require_php}`,
				draft:				false,
				prerelease:			false
			}
			const api_url = `https://${package.wporg.git.user}:${token}@api.github.com/repos/${repo}/releases`;
			return [ api_url, req_data ];
		};

		const upload_release_zip = (zip_path, release_data ) => {

		}

		(async () => {
			let release_data;
			const [ repo, branch, token ] = await get_repo_data();
			const [ api_url, req_data ] = get_release_data();

			current_task = doing('Creating release on github.com', 'Done','Failed');

			try {
				release_data = await send_api_request( api_url, req_data );
				current_task.ok()
			} catch(err1) {
				if ( !!err1.errors && err1.errors.filter( e => e.code==='already_exists' ).length ) {
					current_task.fail('Already exists')
					let api_get_release_url = `https://${package.wporg.git.user}:${token}@api.github.com/repos/${repo}/releases/tags/${package.version}`;
					current_task = doing('Get existing release from github.com', 'Done','Failed');
					try {
						release_data = await send_api_request( api_get_release_url, null );
						current_task.ok()
					} catch(err2) {
						current_task.fail()
						reject(err2);
						return;
					}
				} else {
					current_task.fail()
					reject(err1);
					return;
				}
			}


			let package_path, resp, upload_url, data;

			// create_or_get_release()
			current_task = doing('Create upload package', 'Done','Fail');
			try {
				package_path = await pack.run( false, true );
				current_task.ok()
			} catch(err) {
				current_task.fail()
				reject(err)
				return;
			}

			upload_url = release_data.upload_url.replace(/\{.+$/,'')
			upload_url = `${upload_url}?name=${package_path.split('/').pop()}`;

			current_task = doing('Uploading file', 'Done','Failed');
			try {
				/*
				data = fs.readFileSync( package_path );
				/*/
				data = fs.createReadStream( package_path, { bufferSize: 4 * 1024 } );
				//*/
				resp = await send_api_request(
					upload_url,
					data,
					{
						'Content-Length' : fs.statSync(package_path).size,
						'Content-Type' : 'application/zip',
						'Authorization' : `token ${token}`,
					}
				)
				current_task.ok()
			} catch(err) {
				current_task.fail()
				reject(err)
			}

			resolve();
		})()

//		const [ api_url, req_data ] = await get_release_data();

	} );

}



module.exports = { setup, run }
