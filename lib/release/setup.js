const fs = require('fs');
const prompts = require('prompts');
const https = require('https');
const exec = require('child_process');
const wp = require('../wp-header.js');

const build = package => {
	const config = { prebuild: [], build: [] };
	let textdomain, domainpath;

	try {
		// find gulp build task
		console.log( `... detecting gulp tasks` );
		const tasks = JSON.parse( exec.execSync('gulp --tasks-json',{stdio:['pipe','pipe','ignore']}) );
		tasks.nodes.forEach( task => {
			if ( ['dist','build'].indexOf( task.label ) !== -1 ) {
				console.log( `... added 'gulp ${task.label}' to build` );
				config.build.push( `gulp ${task.label}` );
			}
		})
	} catch(err) {
		console.log( `... no gulp tasks` );
	}

	try {
		console.log( `... detecting i18n` );
		// i18n
		textdomain = wp.read_header_tag( wp.find_package_file(), 'Text Domain' ) || package.name;
		domainpath = wp.read_header_tag( wp.find_package_file(), 'Domain Path' ) || 'languages';

		domainpath = domainpath.replace(/^\/+|\/+$/g,'');
		if ( !! textdomain ) {
			console.log( `... added 'wp i18n make-pot' for domain ${textdomain}` );
			config.prebuild.push( `wp i18n make-pot . ${domainpath}/${textdomain}.pot --domain=${textdomain}` )
		}
	} catch(err) {
		console.log( `... no i18n` );
		throw(err)
	}
	return config;
}

const git = async package => {
	const remote = exec.execSync( 'git remote get-url origin', { encoding: 'utf8' } ).trim();
	const [ host , ] = remote.match('(github\.com|bitbucket\.org)');
	let user;
	try {
		// get user from config
		user = (host === 'github.com') ? package.wporg.github.user : package.wporg.git.user;
		console.log(user)
	} catch( err ) {}
	if ( user === undefined ) {
		user = exec.execSync( 'git config user.name', { encoding: 'utf8' } ).trim();
	}
	console.log( `... detected ${host}` );

	const user_prompt = await prompts([
		{
			type: 'text',
			name: 'user',
			message: `${host} username [${user}]:`,
			initial: user
		}
	], { onCancel: process.exit } );

	if ( host === 'github.com' && process.platform === 'darwin' ) {
		let token,
			token_label;
		console.log('let\'s see if there is an access token.');
		try {
			token = exec.execSync( `security find-generic-password -a ${user_prompt.user} -s "https://api.github.com" -w`, { encoding: 'utf8' } );
			console.log('Yep, there is!');
		} catch( err ) {
			console.log('Nope, no token found.');
			console.log('Please create an access token with Scope `repo` enabled on github: <https://github.com/settings/tokens>');

			const token_prompt = await prompts([
				{
					type: 'password',
					name: 'token',
					message: `Access token:`,
					initial: ''
				},
				{
					type: 'text',
					name: 'label',
					message: 'Label in MacOS Keychain:',
					initial: `<${user_prompt.user}@api.github.com> wporg-release`
				}
			], { onCancel: process.exit });

			if ( token_prompt.token !== '' ) {
				exec.execSync( `security add-generic-password -a "${user_prompt.user}" -l "${token_prompt.label}" -s "https://api.github.com" -j "Generated by mcguffin/wporg-release" -w "${token_prompt.token}"` );
				console.log('Token added to MacOS Keychain');
				console.log(`Account: ${user_prompt.user}`);
				console.log(`Where: https://api.github.com` );
				console.log(`Label: ${token_prompt.label}`);
			}
		}
	}
	return { ...user_prompt, host };

}

const is_wporg = package => new Promise( ( resolve, reject ) => {

	const type = wp.get_package_type();
	let api_url;
	let resp_data = '';
//package.name='acf-dropzone'
	if ( type === 'plugin' ) {
		api_url = `https://api.wordpress.org/plugins/info/1.2/?action=plugin_information&request[slug]=${package.name}`;
	} else if ( type === 'theme' ) {
		api_url = `https://api.wordpress.org/themes/info/1.1/?action=theme_information&request[slug]=${package.name}`;
	}
	console.log(`... check if there is a ${type} with slug '${package.name}' at wporg`);


	const req = https.request( api_url, {
		method: 'GET',
		headers: {
			'User-Agent' : 'Nodejs'
		}
	}, resp => {
		resp.setEncoding('utf8');
		resp.on('data',data => {
			resp_data += data;
		});
		resp.on('end',() => {
			const resp = JSON.parse( resp_data );
			const result = !! resp.slug;
			if ( result ) {
				console.log( '... Yep, there is!' )
			} else {
				console.log( `... nope, there isn\'t.` )
			}
			resolve( result );
		});
		resp.on('error',error => {
			console.log(`... Something went terribly wrong!`);
			console.log( error )
			reject(error);
		});
	});
	req.end();

} );

const wporg = async package => {
	const config = {};
	const type = wp.get_package_type();
	const active = await is_wporg( package );

	if ( ! active ) {
		return false;
	}

	if ( type === 'plugin' ) {
		config.svn = `https://plugins.svn.wordpress.org/${package.name}/`;
	} else if ( type === 'theme' ) {
		config.svn = false;
	}
	// mk assets dir
	const response = await prompts([
		{
			type: 'text',
			name: 'assets',
			message: `Assets directory [.wporg/]:`,
			initial: '.wporg'
		}
	], { onCancel: process.exit });

	console.log( `... creating assets directory at ${response.assets}` );

	fs.mkdirSync( response.assets, { recursive: true } );

	return {...config, ...response };

};

const config = async ( package = {} ) => {
	const add_step = ( config, step ) => {
		if ( ! config.steps ) {
			config.steps = [];
		}
		if ( config.steps.indexOf( step ) === -1 ) {
			config.steps.push( step );
		}
	};
	let stable_tag;
	let config = package.wporg || {};


	if ( ! config.type ) {
		console.log( 'Detecting package type' );
		config.type = wp.get_package_type();
		console.log(config.type);
	}
	if ( ! config.type ) {
		console.log('Couldn\'t identify Package Type');
		console.log('Plugin must have a PHP file in their root directory containing the plugin meta.');
		console.log('A Theme has its metadata either in ./style.css or ./src/scss/style.scss');
		throw('package type detection failed' );
	}

	add_step(config,'build')

	console.log( '# Configuring build process' );
	config.build = build( package );

	console.log( '# Configuring git release process' );
//	console.log('Configure WP-' + ( config.type == 'plugin' ? 'Plugin' : 'Theme' ) + ' ' + wp.get_package_name() );

	let gitresult = await git( package );

	if ( gitresult ) {
		if ( gitresult.host === 'github.com' ) {
			add_step(config,'github')
			console.log( `... release process will create a release at ${gitresult.host}` );
			config['github'] = gitresult;
		} else {
			add_step(config,'git')
			console.log( `... release process will create a new tag at ${gitresult.host}` );
			config['git'] = gitresult;
		}
	}

	console.log( '# Configuring wporg release process' );
	let wporgresult = await wporg( package );
	if ( wporgresult !== false ) {
		config['wporg'] = wporgresult;
		if ( !! wporgresult.svn ) {
			console.log( `... the release process will commit to ${wporgresult.svn}` );
			add_step( config, 'wporg' )
		} else {
			console.log( `... the release process will create a package zipfile` );
			console.log( `... you will have to upload it manually` );
			add_step( config, 'pack' )
		}
	} else {
		console.log( `... aborting wporg.` );
	}
	return config;
}

module.exports = () => {
	const package = require( process.cwd() + '/package.json' );
	return new Promise( (resolve, reject) => {
		try {
			config( package ).then( config => {
				package.wporg = config;
				fs.writeFileSync( './package.json', JSON.stringify( package, null, 2 ) );
				resolve();
			} );
		} catch (err) {
			console.log(err);
			reject();
		}
	});

}
